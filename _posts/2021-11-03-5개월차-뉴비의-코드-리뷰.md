---
layout: post
title:  "5개월차-뉴비의-코드-리뷰"
date:   2021-11-03 14:18:01
author: 허민지
categories: Experience
tags:	experience
cover:  "/assets/2021-11-03/w-g-penguin.jpg"
---

# 목차

- [인사말](##인사말)
- [코드 리뷰](##코드리뷰)
  - promise.all()
  - body는 readonly로 취급
  - return의 묘미
    - 바로 return 하기 
    - return? return await? 
  - try-catch 블록은 작게 잡기
  - 메세지, validation 파일 분리
  - 알잘딱깔센 함수명, 변수명
  - 주석은 매너
- [마무리](##마무리)

# 5개월차 뉴비와 코드 리뷰

![senior_developer_junior_developer](/assets/2021-11-03/senior-junior.png)

## 인사말

안녕하세요 백엔드팀 허민지입니다. 시간이 벌써 빠르게 흘러 비브로스에 입사한 지 약 5개월이 되어갑니다. 아직 개발자라고 자신을 소개하기에는 부끄러운 실력이지만 어느새 본격 신입 생활에 접어들었습니다. 그동안 자바스크립트와 타입스크립트를 다루며, 팀 장기 프로젝트에 투입되고 일감을 할당받아 작게나마 똑닥 서비스에 기여하고 있습니다. 

똑닥 백엔드팀은 코드 리뷰 문화가 있습니다. 코드 리뷰란 코드 작성자가 다른 개발자들의 피드백을 바탕으로 코드 내용을 수정하는 작업을 의미합니다. 이 과정에 다른 분들의 기술적인 피드백으로 더 효과적인 코드를 작성할 수 있습니다. 또한 운영 서버 배포 전 서비스에 타격이 있을 만한 문제와 버그를 바로 잡을 수 있습니다. 백엔드팀 모두 기능 개발 후 코드 리뷰를 받으며 최소 2명에게 승인을 받아야 운영에 반영할 수 있습니다. 특히 자바스크립트와 타입스크립트 초보자인 저에게 신규입사자 과제 때부터 진행되어 온 코드 리뷰는 더 효율적인 코드를 위해 고민하고 작성하는 데 정말 많은 도움이 되었다고 단언할 수 있습니다. 

해당 포스팅을 통해 신규 입사자 과제부터 똑닥 서비스 투입 후 제가 받은 코드 리뷰를 간단한 예제를 통해 공유하여 많은 분들께 도움이 되고자 합니다. 

## 코드 리뷰

1. Promise.all()

   아래에 있는 코드를 확인해보시면 `buildAccount()` 함수는  `await`으로 비동기 처리를 두 번 합니다.  그러나 저희는 해당 비동기 부분을 병렬적으로 **순차처리**할 필요가 없습니다. 에러 없이 데이터베이스에 새로운 "user"와 "tutor"가 잘 생성되면 그만입니다. 이때 `promise.all()`으로 한 번에 처리하는 것이 더 효과적입니다.

   코드 리뷰 전

   ```typescript
   const buildAccount = async (fields) => { 
   	const { name, email } = fields;
     // ... validation 코드 중략 
     await createTutor(name, email).then(throwIfError());
     await createStudent(name, email).then(throwIfError());
     // ... 다른 코드 로직
   }
   ```

   코드 리뷰 후 

   ```typescript
   const buildAccount = async (fields) => { 
   	const { name, email } = fields;
     // .... validation 코드 중략 
     await Promise.all([
       	createTutor(name, email).then(throwIfError()), 
       	createStudent(name, email).then(throwIfError())
     ]);
    // ... 다른 코드 로직
   }
   ```

2. body는 **readonly**로 취급

   예를 들어 사용자가 전화번호를 입력할 때 `-` (하이픈)을 중간에 입력하는 경우가 있습니다. 전화번호를 기호 없이 숫자만 추출하여 데이터베이스에 저장하고 싶어 숫자만 return 받을 수 있는 `onlyNumber()`라는 함수를 만든다는 가정해봅니다. 

   코드 리뷰 전 내용을 확인하면 `exec()`는 숫자만 추출하기 위해 원본 request body의 `phone` 값을 변경합니다. 하지만 Request body는 **'readonly'**로 취급해야 하며 입력값 왜곡은 절대 금지입니다. 이처럼 입력값을 활용해야 할 때 lodash의 `_.clonedeep`을 사용해 body값을 깊은 복사합니다.

   코드 리뷰 전 

   ```typescript
   import * as _ from 'lodash';
   
   // 숫자만 추출하여 저장하는 함수 
   const onlyNumber = (str: string): string => str.replace(/[^\d]/g, '');
   
   const exec = async (body) => {
    	// ... doing something 
   	body.phone = onlyNumber(body.phone)
   }
   ```

   코드 리뷰 후 

   ~~~typescript
   import * as _ from 'lodash';
   
   // 숫자만 추출하여 저장하는 함수 
   const onlyNumber = (str: string) => str.replace(/[^\d]/g, '');
   
   const exec = async (body) => {
   	const queryClone = _.cloneDeep(body);
     const { name, phone, address } = queryClone; 
     // ... finish operation
   }
   ~~~

3. return의 묘미

   - 바로 return 하기 

     필요없는 변수는 만들지 않습니다. 바로 return 할 수 있는 코드는 바로 return 합니다.

     코드 리뷰 전 

     ```typescript
     const createUser = async (name, email) => {
     	// ... validation 코드 중략
     	const newUser = UserModel.create({
     		name,
     		email,
     		createdAt: new Date(),
     		updatedAt: new Date(),
     	});
       return newUser;
     }
     ```

     코드 리뷰 후

     ```typescript
     const createUser = async (name, email) => {
     	// ... validation 코드 중략
     	return UserModel.create({
     		name,
     		email,
     		createdAt: new Date(),
     		updatedAt: new Date(),
     	});
     }
     ```

   - return? return await?

     에러를 추후 handling 하는 로직도 없으며, 사용자 또한 비동기 처리 과정에 대한 문제 발생 여부를 알 필요가 없다고 가정해봅니다. 그럼 return-await이 아닌 바로 return을 해 백그라운드에서 비동기 처리하도록 합니다.

     코드 리뷰 전

     ```typescript
     const postOrder = async (body) => {
       const { userId, name, address, phone } = body;
       // ... validation 코드 중략
       return await OrderModel.create({
         userId,
         name,
         address,
         phone,
         createdAt: new Date(),
         updatedAt: new Date(),
       }) 
     };
     ```

     코드 리뷰 전 

     ```typescript
     const createUser = async (body) => {
       const { userId, name, address, phone } = body;
       // ... validation 코드 중략
       return OrderModel.create({
         userId,
         name,
         address,
         phone,
         createdAt: new Date(),
         updatedAt: new Date(),
       }) 
     };
     ```

4. try-catch 블록은 작게 잡기

   `try` 블록 안에 여러 번의 비동기 작업이 진행된다고 가정해봅니다. 그 중 하나에서 에러가 발생했습니다. 그러나 `catch` 블록을 통해 해당 에러가 잡혀도 우리는 해당 에러가 어떤 비동기 처리 작업 때 발생했는지 알 수 없습니다.  이때는 try-catch 블록 대신 개별적으로 promise 뒤에 `catch()`를 추가하든지 아니면 error가 정확히 어디서 발생했는지 알기 위해 try-catch 블록을 작게 잡습니다. 

   코드 리뷰 전 

   ```typescript
   const createUser = async (body) => {
     try {
       const { name, email } = body;
       // ... validation 코드 중략
       const result = await someFunction(body);
       const resultTwo = await otherFunction(body);
       return someOtherFunction(result, resultTwo);
     } catch (error) {
     	throw new Error('Oops')
     }
   };
   ```

   코드 리뷰 후 

   ```typescript
   const createAccount = async (body) => {
     const { name, email } = body;
     // ... validation 코드 중략
     const result = await someFunction(body).catch((err) => {
       throw new Error('Oops from A')
     });
     const resultTwo = await otherFunction(body).catch((err) => {
       throw new Error('Oops from B')
     });
     return someOtherFunction(result, resultTwo).catch((err) => {
       throw new Error('Oops from Final Function')
     });
   };
   ```

5. 메세지, 입력값 검증 파일 분리

   에러 반환 메시지 및 입력값 검증하는 함수는 별도의 파일을 생성해 service 파일과 분리합니다. 

   코드 리뷰 전 

   ```typescript
   const createUser = async (body) => {
     const { name, email } = body;
     
     if (_.isNil(name) || _.isEmpty(name)) {
       throw Error('이름 누락되었습니다.')
     }
     
     if (_.isNil(email) || _.isEmpty(email)) {
       throw Error('이메일 누락되었습니다.')
     }
     
     const result = await someFunction(body).catch((err) => {
       console.log(err)
     });
     
     return someOtherFunction(result).catch((err) => {
       console.log(err)
     });
   };
   ```

   코드 리뷰 후 

   ```typescript
   // user.message 파일
   export const message {
     NAME_REQUIRED: '이름 누락되었습니다.',
     EMAIL_REQUIRED: '이메일 누락되었습니다.',
   }
   
   // user.validate 파일
   import * as message from './user.message';
     
   export const validateName = (name) => {
      if (_.isNil(name) || _.isEmpty(name)) {
       throw Error(message.NAME_REQUIRED)
     }
   }
   
   export const validateEmail = (email) => {
     if (_.isNil(email) || _.isEmpty(email)) {
       throw Error(message.EMAIL_REQUIRED)
     }
   }
     
   // user.service 파일
   import * as validate from './user.valiate';
   
   const createUser = async (body) => {
     const { name, email } = body;
     
     validateName(name);
     validateEmail(email);
       
     const result = await someFunction(body).catch((err) => {
       console.log(err)
     });
     
     return someOtherFunction(result).catch((err) => {
       console.log(err)
     });
   };
   ```

6. 알잘딱깔센 함수명, 변수명

   함수 또는 변수는 해당 역할과 수행 목적과 맞는 이름이어야 합니다. 정확한 함수/변수명일수록 코드 리뷰어도 더 효과적으로 내용을 이해하고 피드백을 줄 수 있습니다. 

   코드 리뷰 전 

   ```typescript
   // 불명확한 함수명
   const func = (body) => {
     // 불명확한 변수명
   	const a = 18;
    	if (body.age < a) {
       throw new Error(`만 ${a} 미만은 일반 회원가입이 불가능합니다.`)
     }
     return UserModel.create({
       name: body.name,
       email: body.email,
       age: body.age,
       createdAt: new Date(),
       updatedAt: new Date(),
     })
   };
   ```

   코드 리뷰 후 

   ```typescript
   // 명확한 함수명
   const createUser = (body) => {
     // 명확한 변수명
   	const AGE_LIMIT = 18;
    	if (body.age < AGE_LIMIT) {
       throw new Error(`만 ${AGE_LIMIT} 미만은 일반 회원가입이 불가능합니다.`)
     }
     return UserModel.create({
       name: body.name,
       email: body.email,
       age: body.age,
       createdAt: new Date(),
       updatedAt: new Date(),
     })
   };
   ```

7. 주석은 매너

   큰 함수나 인터페이스 같은 경우 주석을 통해 해당 함수의 역할과 목적을 표기합니다. 주석은 적절한 키워드 및 설명이 내재하여 있어야 합니다. 

## 마무리

5개월 동안 받았던 코드 리뷰를 하나하나 확인해보니 저의 코드가 5개월간 진화(?)했다는 것을 느낄 수 있었습니다. 저는 오늘도 코드 리뷰를 통해 더 효율적인 코드를 작성하고, 똑닥 서비스 및 아키텍처 전반을 세심하게 살피고 있습니다. 이처럼 코드 리뷰 문화를 통해 똑닥 백엔드팀은 더 나은 서비스를 위해 함께 고민하고 기술을 공유합니다. 

긴 글 읽어주셔서 감사합니다.  

## 비브로스는 현재 채용 진행중입니다

더 자세한 내용은 해당 링크를 통해 확인하실 수 있습니다:

- [원티드](https://www.wanted.co.kr/search?query=%EB%B9%84%EB%B8%8C%EB%A1%9C%EC%8A%A4)
- [비브로스](https://www.bbros.co.kr/career)

